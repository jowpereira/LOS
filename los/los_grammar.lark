// ðŸš€ LOS GRAMMAR v3.0 - Linguagem de OtimizaÃ§Ã£o Simples
// GramÃ¡tica Lark para o parser LOS v3 (BilÃ­ngue PT/EN)
// Suporta a nova sintaxe simplificada e declarativa

?start: statement+

?statement: import_stmt
          | set_decl
          | param_decl
          | var_decl
          | objective
          | constraint_block

// --- IMPORTS ---
import_stmt: "import" STRING -> import_model
           | "importar" STRING -> import_model

// --- SETS (Conjuntos) ---
set_decl: "set" IDENTIFICADOR ("=" set_expr)? -> set_declaration
        | "conj" IDENTIFICADOR ("=" set_expr)? -> set_declaration

?set_expr: "{" set_elements "}" -> set_literal
         | expression ".." expression -> set_range
         | expression ".." expression "step" expression -> set_range_step
         | "{" expression "in" IDENTIFICADOR ("where" logic_expr)? "}" -> set_filter
         | IDENTIFICADOR -> set_ref
         | IDENTIFICADOR set_op IDENTIFICADOR -> set_operation

set_elements: (expression ("," expression)*)?
set_op: SET_UNION | SET_INTER | SET_DIFF | SET_CROSS

// --- PARAMETERS (ParÃ¢metros) ---
param_decl: "param" IDENTIFICADOR ("[" indices "]")? ("=" expression)? -> param_declaration

// --- VARIABLES (VariÃ¡veis) ---
var_decl: "var" IDENTIFICADOR ("[" indices "]")? (":" var_type)? (var_bounds)? -> var_declaration

var_type: INT_TYPE | BIN_TYPE | CONT_TYPE

var_bounds: GE expression (LE expression)? -> bounds_ge_le
          | LE expression (GE expression)? -> bounds_le_ge
          | EQ expression -> bounds_eq
          | "in" set_expr -> bounds_in_set

// --- OBJECTIVE (Objetivo) ---
objective: obj_sense ":" expression -> objective_decl

obj_sense: MIN | MAX

// --- CONSTRAINTS (RestriÃ§Ãµes) ---
constraint_block: "st" ":" constraint_item+ -> constraint_block
                | "sa" ":" constraint_item+ -> constraint_block
                | "subject" "to" ":" constraint_item+ -> constraint_block
                | "sujeito" "a" ":" constraint_item+ -> constraint_block

constraint_item: (IDENTIFICADOR ("[" indices "]")? ":")? logic_expr (loop_multiplo)? -> constraint_named

// --- EXPRESSIONS ---
?expression: sum_expr

?sum_expr: sum_expr "+" term -> add
         | sum_expr "-" term -> sub
         | term

?term: term "*" factor -> mul
     | term "/" factor -> div
     | term "%" factor -> mod
     | factor

?factor: power

?power: atom "^" factor -> pow
      | atom "**" factor -> pow
      | atom

?atom: NUMBER -> number
     | STRING -> string_literal
     | IDENTIFICADOR -> var_or_param
     | IDENTIFICADOR "." IDENTIFICADOR -> dataset_coluna
     | IDENTIFICADOR "[" indices "]" -> indexed_var
     | func_call
     | aggregation
     | if_expr
     | "(" expression ")"

// --- LOGIC EXPRESSIONS ---
?logic_expr: logic_or

?logic_or: logic_or "or" logic_and -> or_op
         | logic_or "ou" logic_and -> or_op
         | logic_and

?logic_and: logic_and "and" logic_not -> and_op
          | logic_and "e" logic_not -> and_op
          | logic_not

?logic_not: "not" logic_comp -> not_op
          | "nao" logic_comp -> not_op
          | logic_comp

?logic_comp: expression rel_op expression
           | expression

rel_op: LE | GE | EQ | NE | LT | GT | EQ_ASSIGN

// --- SPECIAL CONSTRUCTS ---
aggregation: SUM "(" expression (loop_multiplo)? ")" -> sum
           | PROD "(" expression (loop_multiplo)? ")" -> prod
           | MIN "(" expression ("," expression)* ")" -> min_func
           | MAX "(" expression ("," expression)* ")" -> max_func

func_call: IDENTIFICADOR "(" arguments ")"

if_expr: "if" "(" logic_expr "," expression "," expression ")" -> if_inline
       | "se" "(" logic_expr "," expression "," expression ")" -> if_inline

loop_multiplo: ("for" | "para") loop_item ("," loop_item)*

loop_item: IDENTIFICADOR "in" set_expr ("where" logic_expr)? -> loop_simple
         | IDENTIFICADOR "em" set_expr ("onde" logic_expr)? -> loop_simple

indices: expression ("," expression)*
arguments: expression ("," expression)*

// --- TERMINALS ---
// Keywords for Types
INT_TYPE: "int" | "inteiro"
BIN_TYPE: "bin" | "binario"
CONT_TYPE: "continuous" | "continua"

// Set Operators
SET_UNION: "|"
SET_INTER: "&"
SET_DIFF: "\\"
SET_CROSS: "*"

STRING: /'[^']*'/ | /"[^"]*"/
// F17: NUMBER does NOT match leading negative â€” handled by subtraction in expression grammar
NUMBER: /\d+(\.\d+)?([eE][+-]?\d+)?/

// Keywords for Sense
MIN: "min" | "minimize" | "minimizar"
MAX: "max" | "maximize" | "maximizar"

// Keywords for Aggregation
SUM: "sum" | "soma"
PROD: "prod"

// Relational Operators
LE: "<="
GE: ">="
EQ: "=="
NE: "!="
LT: "<"
GT: ">"
EQ_ASSIGN: "="

IDENTIFICADOR.-1: /[a-zA-Z_Ã€-Ã¿][a-zA-Z0-9_Ã€-Ã¿]*/

%import common.WS
%import common.CPP_COMMENT
%import common.SH_COMMENT
%ignore WS
%ignore CPP_COMMENT
%ignore SH_COMMENT  // F18: Support # comments (Python-style)